# -*- coding: utf-8 -*-
"""DynaMacro_Notes_Code

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EjvUmNJ2wgMzOHHfI-_Cc4B4sxuzzI-m

# Utility Function
"""

# utility_model.py
# -----------
# This code models and graphs the utility function from Einarsson and Marquis (1997).

#%% Imports from Python
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from types import SimpleNamespace

#%% Utility Model Class
class UtilityModel():
    '''
    Methods:
        __init__(self, **kwargs) -> Initializes the utility model.
        setup(self, **kwargs) -> Sets parameters and grids.
        compute_utility(self, c_m, c_h) -> Computes the utility function.
        plot_utility(self) -> Generates and displays the utility plot.
    '''

    #%% Constructor
    def __init__(self, **kwargs):
        '''
        Initializes the utility model.

        Optional kwargs:
            All parameters can be overridden with kwargs.
        '''
        print('--------------------------------------------------------------------------------------------------')
        print('Utility Model')
        print('--------------------------------------------------------------------------------------------------\n')
        print('   This model computes and visualizes the utility function u(c_t^m, c_t^h) = η ln c_t^h + ln c_t^m.')
        print('   Based on Einarsson and Marquis (1997) for household consumption preferences.\n')

        self.setup(**kwargs)

    #%% Set up model
    def setup(self, **kwargs):
        '''
        Sets parameters and creates grids for consumption levels.

        Input:
            self : UtilityModel class.
            kwargs : Override default parameters if provided.
        '''
        # Namespace for parameters and grids
        setattr(self, 'par', SimpleNamespace())
        par = self.par

        print('\n--------------------------------------------------------------------------------')
        print('Parameters:')
        print('--------------------------------------------------------------------------------\n')

        # Utility function parameters
        par.eta = 1.825  # Preference for home goods over market goods
        par.beta = 0.96   # Discount factor (for conceptual lifetime utility)
        par.c_m_min = 0.1  # Minimum market consumption (avoid log(0))
        par.c_m_max = 10.0  # Maximum market consumption
        par.c_h_min = 0.1  # Minimum home consumption
        par.c_h_max = 10.0  # Maximum home consumption
        par.grid_size = 100  # Number of points in each grid

        # Update parameters with kwargs if provided
        for key, val in kwargs.items():
            setattr(par, key, val)

        # Create consumption grids
        par.c_m_grid = np.linspace(par.c_m_min, par.c_m_max, par.grid_size)
        par.c_h_grid = np.linspace(par.c_h_min, par.c_h_max, par.grid_size)

        # Validate parameters
        assert par.eta > 0.0
        assert par.beta > 0.0 and par.beta < 1.0
        assert par.c_m_max > par.c_m_min > 0.0
        assert par.c_h_max > par.c_h_min > 0.0
        assert par.grid_size > 5

        print(f'eta: {par.eta}')
        print(f'beta: {par.beta}')
        print(f'c_m range: [{par.c_m_min}, {par.c_m_max}]')
        print(f'c_h range: [{par.c_h_min}, {par.c_h_max}]')

    #%% Compute Utility Function
    def compute_utility(self, c_m, c_h):
        '''
        Computes the utility function u(c_t^m, c_t^h) = η ln c_t^h + ln c_t^m.

        Input:
            c_m : Market consumption level(s)
            c_h : Home consumption level(s)
        Output:
            u : Utility value(s)
        '''
        par = self.par
        u = par.eta * np.log(c_h) + np.log(c_m)
        return u

    #%% Plot Utility Function
    def plot_utility(self):
        '''
        Generates a 3D surface plot of the utility function.
        '''
        par = self.par
        c_m_grid, c_h_grid = np.meshgrid(par.c_m_grid, par.c_h_grid)
        u_grid = self.compute_utility(c_m_grid, c_h_grid)

        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection='3d')
        surf = ax.plot_surface(c_m_grid, c_h_grid, u_grid, cmap='viridis')
        ax.set_xlabel('Market Consumption ($c_t^m$)')
        ax.set_ylabel('Home Consumption ($c_t^h$)')
        ax.set_zlabel('Utility ($u$)')
        ax.set_title('Utility Function: $u(c_t^m, c_t^h) = η ln c_t^h + ln c_t^m$, η = 1.825')
        fig.colorbar(surf, shrink=0.5, aspect=5)
        plt.show()

#%% Run the Model
if __name__ == "__main__":
    # Initialize and run the model
    model = UtilityModel()
    model.plot_utility()

"""# Time Constraint"""

#%% Time Constraint Model Class
class TimeConstraintModel():
    '''
    Methods:
        __init__(self, **kwargs) -> Initializes the time constraint model.
        setup(self, **kwargs) -> Sets parameters and grids.
        compute_feasible_region(self, n1, n2) -> Computes feasible n3 values.
        plot_constraint(self) -> Generates and displays the constraint plot.
    '''

    #%% Constructor
    def __init__(self, **kwargs):
        '''
        Initializes the time constraint model.

        Optional kwargs:
            All parameters can be overridden with kwargs.
        '''
        print('--------------------------------------------------------------------------------------------------')
        print('Time Constraint Model')
        print('--------------------------------------------------------------------------------------------------\n')
        print('   This model visualizes the time constraint n_{1t} + n_{2t} + n_{3t} <= 1.')
        print('   Based on Einarsson and Marquis (1997) for household time allocation.\n')

        self.setup(**kwargs)

    #%% Set up model
    def setup(self, **kwargs):
        '''
        Sets parameters and creates grids for time allocation.

        Input:
            self : TimeConstraintModel class.
            kwargs : Override default parameters if provided.
        '''
        # Namespace for parameters and grids
        setattr(self, 'par', SimpleNamespace())
        par = self.par

        print('\n--------------------------------------------------------------------------------')
        print('Parameters:')
        print('--------------------------------------------------------------------------------\n')

        # Time constraint parameters
        par.n_min = 0.0  # Minimum time allocation
        par.n_max = 1.0  # Maximum time allocation (normalized to 1 unit)
        par.grid_size = 100  # Number of points in each grid

        # Update parameters with kwargs if provided
        for key, val in kwargs.items():
            setattr(par, key, val)

        # Create time allocation grids for n1 and n2
        par.n1_grid = np.linspace(par.n_min, par.n_max, par.grid_size)
        par.n2_grid = np.linspace(par.n_min, par.n_max, par.grid_size)

        # Validate parameters
        assert par.n_max > par.n_min
        assert par.grid_size > 5

        print(f'n range: [{par.n_min}, {par.n_max}]')
        print(f'grid_size: {par.grid_size}')

    #%% Compute Feasible Region
    def compute_feasible_region(self, n1, n2):
        '''
        Computes feasible n3 values given n1 and n2 under the constraint n1 + n2 + n3 <= 1.

        Input:
            n1 : Market work time allocation(s)
            n2 : Home production time allocation(s)
        Output:
            n3 : Feasible formal training time allocation(s)
        '''
        par = self.par
        n3 = 1.0 - n1 - n2
        # Ensure n3 is non-negative and within bounds
        n3 = np.maximum(n3, 0.0)
        n3 = np.minimum(n3, 1.0)
        return n3

    #%% Plot Time Constraint
    def plot_constraint(self):
        '''
        Generates a 3D surface plot of the feasible region for the time constraint.
        '''
        par = self.par
        n1_grid, n2_grid = np.meshgrid(par.n1_grid, par.n2_grid)
        n3_grid = self.compute_feasible_region(n1_grid, n2_grid)

        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection='3d')
        surf = ax.plot_surface(n1_grid, n2_grid, n3_grid, cmap='viridis', alpha=0.8)
        ax.set_xlabel('Market Work ($n_{1t}$)')
        ax.set_ylabel('Home Production ($n_{2t}$)')
        ax.set_zlabel('Formal Training ($n_{3t}$)')
        ax.set_title('Time Constraint: $n_{1t} + n_{2t} + n_{3t} \leq 1$')
        ax.set_zlim(0, 1)  # Ensure z-axis stays within [0, 1]
        fig.colorbar(surf, shrink=0.5, aspect=5)
        plt.show()

        # Optional 2D projection (feasible triangle)
        plt.figure(figsize=(8, 6))
        plt.tricontourf(n1_grid.flatten(), n2_grid.flatten(), n3_grid.flatten(), levels=10, cmap='viridis')
        plt.plot([0, 1, 0, 0], [0, 0, 1, 0], 'r-', label='Constraint Boundary')
        plt.xlabel('Market Work ($n_{1t}$)')
        plt.ylabel('Home Production ($n_{2t}$)')
        plt.title('Feasible Region of Time Constraint')
        plt.legend()
        plt.grid(True)
        plt.axis('equal')
        plt.show()

#%% Run the Model
if __name__ == "__main__":
    # Initialize and run the model
    model = TimeConstraintModel()
    model.plot_constraint()

"""# Production Function

## Market Production Function
"""

#%% Market Production Model Class
class MarketProductionModel():
    '''
    Methods:
        __init__(self, **kwargs) -> Initializes the market production model.
        setup(self, **kwargs) -> Sets parameters and grids.
        compute_output(self, K_m, N_H, theta) -> Computes the market production function.
        plot_production(self) -> Generates and displays the production plot.
    '''

    #%% Constructor
    def __init__(self, **kwargs):
        '''
        Initializes the market production model.

        Optional kwargs:
            All parameters can be overridden with kwargs.
        '''
        print('--------------------------------------------------------------------------------------------------')
        print('Market Production Model')
        print('--------------------------------------------------------------------------------------------------\n')
        print('   This model visualizes the market production function Y_t = θ_t A_1 (K_t^m)^α_1 (N_{1t} H_t)^(1-α_1).')
        print('   Based on Einarsson and Marquis (1997) for firm output with productivity shocks.\n')

        self.setup(**kwargs)

    #%% Set up model
    def setup(self, **kwargs):
        '''
        Sets parameters and creates grids for capital, labor, and productivity shock.

        Input:
            self : MarketProductionModel class.
            kwargs : Override default parameters if provided.
        '''
        # Namespace for parameters and grids
        setattr(self, 'par', SimpleNamespace())
        par = self.par

        print('\n--------------------------------------------------------------------------------')
        print('Parameters:')
        print('--------------------------------------------------------------------------------\n')

        # Market production function parameters
        par.A1 = 1.0  # Baseline efficiency
        par.alpha1 = 0.3  # Capital's contribution relative to labor
        par.K_m_min = 0.1  # Minimum physical capital
        par.K_m_max = 10.0  # Maximum physical capital
        par.N_H_min = 0.1  # Minimum effective labor
        par.N_H_max = 10.0  # Maximum effective labor
        par.theta_min = 0.9  # Minimum productivity shock
        par.theta_max = 1.1  # Maximum productivity shock
        par.grid_size = 100  # Number of points in each grid

        # Update parameters with kwargs if provided
        for key, val in kwargs.items():
            setattr(par, key, val)

        # Create grids
        par.K_m_grid = np.linspace(par.K_m_min, par.K_m_max, par.grid_size)
        par.N_H_grid = np.linspace(par.N_H_min, par.N_H_max, par.grid_size)
        par.theta_grid = np.linspace(par.theta_min, par.theta_max, par.grid_size)

        # Validate parameters
        assert par.A1 > 0.0
        assert 0.0 < par.alpha1 < 1.0
        assert par.K_m_max > par.K_m_min > 0.0
        assert par.N_H_max > par.N_H_min > 0.0
        assert par.theta_max > par.theta_min > 0.0
        assert par.grid_size > 5

        print(f'A1: {par.A1}')
        print(f'alpha1: {par.alpha1}')
        print(f'K_m range: [{par.K_m_min}, {par.K_m_max}]')
        print(f'N_H range: [{par.N_H_min}, {par.N_H_max}]')
        print(f'theta range: [{par.theta_min}, {par.theta_max}]')

    #%% Compute Market Production Function
    def compute_output(self, K_m, N_H, theta):
        '''
        Computes the market production function Y_t = θ_t A_1 (K_t^m)^α_1 (N_{1t} H_t)^(1-α_1).

        Input:
            K_m : Physical capital level(s)
            N_H : Effective labor level(s)
            theta : Productivity shock level(s)
        Output:
            Y : Market output
        '''
        par = self.par
        Y = theta * par.A1 * (K_m ** par.alpha1) * ((N_H) ** (1 - par.alpha1))
        return Y

    #%% Plot Market Production Function
    def plot_production(self):
        '''
        Generates a 3D surface plot of the market production function.
        '''
        par = self.par
        K_m_grid, N_H_grid = np.meshgrid(par.K_m_grid, par.N_H_grid)
        # Use a fixed theta for simplicity (e.g., mean of range)
        theta_fixed = np.mean([par.theta_min, par.theta_max])
        Y_grid = self.compute_output(K_m_grid, N_H_grid, theta_fixed)

        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection='3d')
        surf = ax.plot_surface(K_m_grid, N_H_grid, Y_grid, cmap='viridis')
        ax.set_xlabel('Physical Capital ($K_t^m$)')
        ax.set_ylabel('Effective Labor ($N_{1t} H_t$)')
        ax.set_zlabel('Market Output ($Y_t$)')
        ax.set_title(f'Market Production Function: $Y_t = \\theta_t A_1 (K_t^m)^{{{par.alpha1}}} (N_{{1t}} H_t)^{{{1-par.alpha1}}}$, ' +
                     f'$\\theta = {theta_fixed:.2f}$, $A_1 = {par.A1}$')
        fig.colorbar(surf, shrink=0.5, aspect=5)
        plt.show()

        # Optional: Vary theta to show shock effect
        theta_values = [par.theta_min, np.mean([par.theta_min, par.theta_max]), par.theta_max]
        plt.figure(figsize=(10, 6))
        for theta in theta_values:
            Y_line = self.compute_output(par.K_m_grid, par.N_H_grid[par.grid_size//2], theta)
            plt.plot(par.K_m_grid, Y_line, label=f'$\\theta = {theta:.2f}$')
        plt.xlabel('Physical Capital ($K_t^m$)')
        plt.ylabel('Market Output ($Y_t$)')
        plt.title('Effect of Productivity Shock on Output')
        plt.legend()
        plt.grid(True)
        plt.show()

#%% Run the Model
if __name__ == "__main__":
    # Initialize and run the model
    model = MarketProductionModel()
    model.plot_production()

"""Home Production Function"""

#%% Home Production Model Class
class HomeProductionModel():
    '''
    Methods:
        __init__(self, **kwargs) -> Initializes the home production model.
        setup(self, **kwargs) -> Sets parameters and grids.
        compute_output(self, k_h, n2_h) -> Computes the home production function.
        plot_production(self) -> Generates and displays the production plot.
    '''

    #%% Constructor
    def __init__(self, **kwargs):
        '''
        Initializes the home production model.

        Optional kwargs:
            All parameters can be overridden with kwargs.
        '''
        print('--------------------------------------------------------------------------------------------------')
        print('Home Production Model')
        print('--------------------------------------------------------------------------------------------------\n')
        print('   This model visualizes the home production function c_t^h = A_2 [α_2 (k_t^h)^λ + (1-α_2) (n_{2t} h_t)^λ]^{1/λ}.')
        print('   Based on Einarsson and Marquis (1997) for household production.\n')

        self.setup(**kwargs)

    #%% Set up model
    def setup(self, **kwargs):
        '''
        Sets parameters and creates grids for home capital and effective labor.

        Input:
            self : HomeProductionModel class.
            kwargs : Override default parameters if provided.
        '''
        # Namespace for parameters and grids
        setattr(self, 'par', SimpleNamespace())
        par = self.par

        print('\n--------------------------------------------------------------------------------')
        print('Parameters:')
        print('--------------------------------------------------------------------------------\n')

        # Home production function parameters
        par.A2 = 1.0  # Home efficiency
        par.alpha2 = 0.166  # Capital versus labor weight
        par.lambda_ = -0.67  # Substitution elasticity
        par.k_h_min = 0.1  # Minimum home capital
        par.k_h_max = 10.0  # Maximum home capital
        par.n2_h_min = 0.1  # Minimum effective labor
        par.n2_h_max = 10.0  # Maximum effective labor
        par.grid_size = 100  # Number of points in each grid

        # Update parameters with kwargs if provided
        for key, val in kwargs.items():
            setattr(par, key, val)

        # Create grids
        par.k_h_grid = np.linspace(par.k_h_min, par.k_h_max, par.grid_size)
        par.n2_h_grid = np.linspace(par.n2_h_min, par.n2_h_max, par.grid_size)

        # Validate parameters
        assert par.A2 > 0.0
        assert 0.0 < par.alpha2 < 1.0
        assert par.lambda_ < 0.0  # CES requires λ < 0 for substitution
        assert par.k_h_max > par.k_h_min > 0.0
        assert par.n2_h_max > par.n2_h_min > 0.0
        assert par.grid_size > 5

        print(f'A2: {par.A2}')
        print(f'alpha2: {par.alpha2}')
        print(f'lambda: {par.lambda_}')
        print(f'k_h range: [{par.k_h_min}, {par.k_h_max}]')
        print(f'n2_h range: [{par.n2_h_min}, {par.n2_h_max}]')

    #%% Compute Home Production Function
    def compute_output(self, k_h, n2_h):
        '''
        Computes the home production function c_t^h = A_2 [α_2 (k_t^h)^λ + (1-α_2) (n_{2t} h_t)^λ]^{1/λ}.

        Input:
            k_h : Home capital level(s)
            n2_h : Effective labor level(s)
        Output:
            c_h : Home production output
        '''
        par = self.par
        term1 = par.alpha2 * (k_h ** par.lambda_)
        term2 = (1 - par.alpha2) * (n2_h ** par.lambda_)
        c_h = par.A2 * (term1 + term2) ** (1 / par.lambda_)
        return c_h

    #%% Plot Home Production Function
    def plot_production(self):
        '''
        Generates a 3D surface plot of the home production function.
        '''
        par = self.par
        k_h_grid, n2_h_grid = np.meshgrid(par.k_h_grid, par.n2_h_grid)
        c_h_grid = self.compute_output(k_h_grid, n2_h_grid)

        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection='3d')
        surf = ax.plot_surface(k_h_grid, n2_h_grid, c_h_grid, cmap='viridis')
        ax.set_xlabel('Home Capital ($k_t^h$)')
        ax.set_ylabel('Effective Labor ($n_{2t} h_t$)')
        ax.set_zlabel('Home Production ($c_t^h$)')
        ax.set_title(f'Home Production Function: $c_t^h = A_2 [\\alpha_2 (k_t^h)^{{λ}} + (1-\\alpha_2) (n_{{2t}} h_t)^{{λ}}]^{{1/λ}}$, ' +
                     f'$A_2 = {par.A2}$, $\\alpha_2 = {par.alpha2}$, $λ = {par.lambda_}$')
        fig.colorbar(surf, shrink=0.5, aspect=5)
        plt.show()

#%% Run the Model
if __name__ == "__main__":
    # Initialize and run the model
    model = HomeProductionModel()
    model.plot_production()

def home_production(k, n2t, ht, A2=1, alpha2=0.166, lamda=-0.67):
    """Calculates home production using the CES function."""
    effective_labor = n2t * ht
    inside_ces = alpha2 * (k**lamda) + (1 - alpha2) * (effective_labor**lamda)
    ch = A2 * (inside_ces**(1/lamda))
    return ch

# Example usage and graphing:
k_values = np.linspace(0.1, 2, 50)  # Capital range (avoid k=0 for lambda < 0)
n2t = 1  # Example time input
ht_values = [0.5, 1, 1.5]  # Different skill levels


plt.figure(figsize=(10, 6))
for ht in ht_values:
    ch_values = [home_production(k, n2t, ht) for k in k_values]
    plt.plot(k_values, ch_values, label=f"ht = {ht}")


plt.xlabel("Home Capital (k)")
plt.ylabel("Home Production (ch)")
plt.title("Home Production Function")
plt.legend()
plt.grid(True)
plt.show()

# Example JSON handling (if needed in your larger project):
import json

# Convert parameters to JSON:
parameters_json = json.dumps(parameters, indent=4)
print(parameters_json)

# Load parameters from JSON:
loaded_parameters = json.loads(parameters_json)

# Using loaded parameters (demonstration):
ch_from_json = home_production(k=0.7, ht=1.2, **loaded_parameters)
print(ch_from_json)

"""# Capital Accumulation

## Market Capital
"""

#%% Market Capital Model Class
class MarketCapitalModel():
    '''
    Methods:
        __init__(self, **kwargs) -> Initializes the market capital model.
        setup(self, **kwargs) -> Sets parameters.
        compute_output(self, k_m, N_H, theta) -> Computes market production.
        simulate_capital(self) -> Simulates capital accumulation.
        plot_capital(self) -> Generates and displays the capital accumulation plot.
    '''

    #%% Constructor
    def __init__(self, **kwargs):
        '''
        Initializes the market capital model.

        Optional kwargs:
            All parameters can be overridden with kwargs.
        '''
        print('--------------------------------------------------------------------------------------------------')
        print('Market Capital Accumulation Model')
        print('--------------------------------------------------------------------------------------------------\n')
        print('   This model simulates and visualizes the market capital accumulation k_{t+1}^m = (1-δ) k_t^m + i_t^m.')
        print('   Investment i_t^m is a fraction of market output Y_t.')
        print('   Based on Einarsson and Marquis (1997) for capital dynamics.\n')

        self.setup(**kwargs)

    #%% Set up model
    def setup(self, **kwargs):
        '''
        Sets parameters for simulation.

        Input:
            self : MarketCapitalModel class.
            kwargs : Override default parameters if provided.
        '''
        # Namespace for parameters
        setattr(self, 'par', SimpleNamespace())
        par = self.par

        print('\n--------------------------------------------------------------------------------')
        print('Parameters:')
        print('--------------------------------------------------------------------------------\n')

        # Market production and capital accumulation parameters
        par.A1 = 1.0  # Baseline efficiency
        par.alpha1 = 0.3  # Capital's contribution relative to labor
        par.delta = 0.1  # Depreciation rate
        par.s = 0.2  # Investment rate (fraction of output)
        par.theta = 1.0  # Fixed productivity (no shocks for simplicity)
        par.N_H = 5.0  # Fixed effective labor (N_{1t} H_t)
        par.k_m_0 = 1.0  # Initial market capital
        par.T = 100  # Number of time periods

        # Update parameters with kwargs if provided
        for key, val in kwargs.items():
            setattr(par, key, val)

        # Validate parameters
        assert par.A1 > 0.0
        assert 0.0 < par.alpha1 < 1.0
        assert 0.0 <= par.delta <= 1.0
        assert 0.0 < par.s < 1.0
        assert par.theta > 0.0
        assert par.N_H > 0.0
        assert par.k_m_0 > 0.0
        assert par.T > 0

        print(f'A1: {par.A1}')
        print(f'alpha1: {par.alpha1}')
        print(f'delta: {par.delta}')
        print(f's: {par.s}')
        print(f'theta: {par.theta}')
        print(f'N_H: {par.N_H}')
        print(f'k_m_0: {par.k_m_0}')
        print(f'T: {par.T}')

    #%% Compute Market Production Function
    def compute_output(self, k_m, N_H, theta):
        '''
        Computes the market production function Y_t = θ_t A_1 (k_t^m)^α_1 (N_{1t} H_t)^(1-α_1).

        Input:
            k_m : Physical capital level(s)
            N_H : Effective labor level(s)
            theta : Productivity shock level(s)
        Output:
            Y : Market output
        '''
        par = self.par
        Y = theta * par.A1 * (k_m ** par.alpha1) * (N_H ** (1 - par.alpha1))
        return Y

    #%% Simulate Capital Accumulation
    def simulate_capital(self):
        '''
        Simulates the market capital accumulation over time.

        Output:
            k_m_path : Array of market capital over time
        '''
        par = self.par
        k_m_path = np.zeros(par.T)
        k_m_path[0] = par.k_m_0

        for t in range(1, par.T):
            # Compute output at current capital
            Y_t = self.compute_output(k_m_path[t-1], par.N_H, par.theta)
            # Compute investment
            i_t_m = par.s * Y_t
            # Update capital
            k_m_path[t] = (1 - par.delta) * k_m_path[t-1] + i_t_m

        return k_m_path

    #%% Plot Capital Accumulation
    def plot_capital(self):
        '''
        Generates a line plot of market capital over time.
        '''
        par = self.par
        k_m_path = self.simulate_capital()
        time = np.arange(par.T)

        plt.figure(figsize=(10, 6))
        plt.plot(time, k_m_path, label='Market Capital ($k_t^m$)')
        plt.xlabel('Time ($t$)')
        plt.ylabel('Market Capital ($k_t^m$)')
        plt.title(f'Market Capital Accumulation: $k_{{t+1}}^m = (1-\\delta) k_t^m + i_t^m$, ' +
                  f'$\\delta = {par.delta}$, $s = {par.s}$')
        plt.grid(True)
        plt.legend()
        plt.show()

#%% Run the Model
if __name__ == "__main__":
    # Initialize and run the model
    model = MarketCapitalModel()
    model.plot_capital()

"""## Home Captial"""

# capital_accumulation_model.py
# -----------
# This code models and graphs both market and home capital accumulation from Einarsson and Marquis (1997).

#%% Imports from Python
import numpy as np
import matplotlib.pyplot as plt
from types import SimpleNamespace

#%% Capital Accumulation Model Class
class CapitalAccumulationModel():
    '''
    Methods:
        __init__(self, **kwargs) -> Initializes the capital accumulation model.
        setup(self, **kwargs) -> Sets parameters.
        compute_market_output(self, k_m, N_H, theta) -> Computes market production.
        compute_home_output(self, k_h, n2_h) -> Computes home production.
        simulate_capital(self) -> Simulates market and home capital accumulation.
        plot_capital(self) -> Generates and displays the capital accumulation plot.
    '''

    #%% Constructor
    def __init__(self, **kwargs):
        '''
        Initializes the capital accumulation model.

        Optional kwargs:
            All parameters can be overridden with kwargs.
        '''
        print('--------------------------------------------------------------------------------------------------')
        print('Capital Accumulation Model (Market and Home)')
        print('--------------------------------------------------------------------------------------------------\n')
        print('   This model simulates and visualizes market and home capital accumulation.')
        print('   Market: k_{t+1}^m = (1-δ) k_t^m + i_t^m, Home: k_{t+1}^h = (1-δ) k_t^h + i_t^h.')
        print('   Based on Einarsson and Marquis (1997) for capital dynamics.\n')

        self.setup(**kwargs)

    #%% Set up model
    def setup(self, **kwargs):
        '''
        Sets parameters for simulation.

        Input:
            self : CapitalAccumulationModel class.
            kwargs : Override default parameters if provided.
        '''
        # Namespace for parameters
        setattr(self, 'par', SimpleNamespace())
        par = self.par

        print('\n--------------------------------------------------------------------------------')
        print('Parameters:')
        print('--------------------------------------------------------------------------------\n')

        # Market production and capital accumulation parameters
        par.A1 = 1.0  # Market efficiency
        par.alpha1 = 0.3  # Market capital's contribution
        par.theta = 1.0  # Fixed productivity (no shocks)
        par.N_H = 5.0  # Fixed effective labor (N_{1t} H_t)
        par.k_m_0 = 1.0  # Initial market capital
        par.s_m = 0.2  # Market investment rate

        # Home production and capital accumulation parameters
        par.A2 = 1.0  # Home efficiency
        par.alpha2 = 0.166  # Home capital versus labor weight
        par.lambda_ = -0.67  # Substitution elasticity
        par.n2_h = 5.0  # Fixed effective labor (n_{2t} h_t)
        par.k_h_0 = 1.0  # Initial home capital
        par.s_h = 0.2  # Home investment rate

        # Shared parameters
        par.delta = 0.1  # Depreciation rate
        par.T = 100  # Number of time periods

        # Update parameters with kwargs if provided
        for key, val in kwargs.items():
            setattr(par, key, val)

        # Validate parameters
        assert par.A1 > 0.0
        assert 0.0 < par.alpha1 < 1.0
        assert par.A2 > 0.0
        assert 0.0 < par.alpha2 < 1.0
        assert par.lambda_ < 0.0
        assert 0.0 <= par.delta <= 1.0
        assert 0.0 < par.s_m < 1.0
        assert 0.0 < par.s_h < 1.0
        assert par.theta > 0.0
        assert par.N_H > 0.0
        assert par.n2_h > 0.0
        assert par.k_m_0 > 0.0
        assert par.k_h_0 > 0.0
        assert par.T > 0

        print(f'A1: {par.A1}, alpha1: {par.alpha1}')
        print(f'A2: {par.A2}, alpha2: {par.alpha2}, lambda: {par.lambda_}')
        print(f'delta: {par.delta}')
        print(f's_m: {par.s_m}, s_h: {par.s_h}')
        print(f'theta: {par.theta}')
        print(f'N_H: {par.N_H}, n2_h: {par.n2_h}')
        print(f'k_m_0: {par.k_m_0}, k_h_0: {par.k_h_0}')
        print(f'T: {par.T}')

    #%% Compute Market Production Function
    def compute_market_output(self, k_m, N_H, theta):
        '''
        Computes the market production function Y_t = θ_t A_1 (k_t^m)^α_1 (N_{1t} H_t)^(1-α_1).
        '''
        par = self.par
        Y = theta * par.A1 * (k_m ** par.alpha1) * (N_H ** (1 - par.alpha1))
        return Y

    #%% Compute Home Production Function
    def compute_home_output(self, k_h, n2_h):
        '''
        Computes the home production function c_t^h = A_2 [α_2 (k_t^h)^λ + (1-α_2) (n_{2t} h_t)^λ]^{1/λ}.
        '''
        par = self.par
        term1 = par.alpha2 * (k_h ** par.lambda_)
        term2 = (1 - par.alpha2) * (n2_h ** par.lambda_)
        c_h = par.A2 * (term1 + term2) ** (1 / par.lambda_)
        return c_h

    #%% Simulate Capital Accumulation
    def simulate_capital(self):
        '''
        Simulates market and home capital accumulation over time.

        Output:
            k_m_path : Array of market capital over time
            k_h_path : Array of home capital over time
        '''
        par = self.par
        k_m_path = np.zeros(par.T)
        k_h_path = np.zeros(par.T)
        k_m_path[0] = par.k_m_0
        k_h_path[0] = par.k_h_0

        for t in range(1, par.T):
            # Market capital
            Y_t = self.compute_market_output(k_m_path[t-1], par.N_H, par.theta)
            i_t_m = par.s_m * Y_t
            k_m_path[t] = (1 - par.delta) * k_m_path[t-1] + i_t_m

            # Home capital
            c_h_t = self.compute_home_output(k_h_path[t-1], par.n2_h)
            i_t_h = par.s_h * c_h_t
            k_h_path[t] = (1 - par.delta) * k_h_path[t-1] + i_t_h

        return k_m_path, k_h_path

    #%% Plot Capital Accumulation
    def plot_capital(self):
        '''
        Generates a line plot of market and home capital over time.
        '''
        par = self.par
        k_m_path, k_h_path = self.simulate_capital()
        time = np.arange(par.T)

        plt.figure(figsize=(10, 6))
        plt.plot(time, k_m_path, label='Market Capital ($k_t^m$)', color='blue')
        plt.plot(time, k_h_path, label='Home Capital ($k_t^h$)', color='orange')
        plt.xlabel('Time ($t$)')
        plt.ylabel('Capital')
        plt.title(f'Capital Accumulation: $k_{{t+1}} = (1-\\delta) k_t + i_t$, ' +
                  f'$\\delta = {par.delta}$, $s_m = {par.s_m}$, $s_h = {par.s_h}$')
        plt.grid(True)
        plt.legend()
        plt.show()

#%% Run the Model
if __name__ == "__main__":
    # Initialize and run the model
    model = CapitalAccumulationModel()
    model.plot_capital()

"""## Human Capital"""

# capital_human_model.py
# -----------
# This code models and graphs market capital and human capital accumulation from Einarsson and Marquis (1997).

#%% Imports from Python
import numpy as np
import matplotlib.pyplot as plt
from types import SimpleNamespace

#%% Capital and Human Model Class
class CapitalHumanModel():
    '''
    Methods:
        __init__(self, **kwargs) -> Initializes the capital and human model.
        setup(self, **kwargs) -> Sets parameters.
        compute_market_output(self, k_m, N_H, theta) -> Computes market production.
        simulate_capital_human(self) -> Simulates market capital and human capital accumulation.
        plot_capital_human(self) -> Generates and displays the accumulation plot.
    '''

    #%% Constructor
    def __init__(self, **kwargs):
        '''
        Initializes the capital and human model.

        Optional kwargs:
            All parameters can be overridden with kwargs.
        '''
        print('--------------------------------------------------------------------------------------------------')
        print('Capital and Human Accumulation Model')
        print('--------------------------------------------------------------------------------------------------\n')
        print('   This model simulates and visualizes market capital and human capital accumulation.')
        print('   Market: k_{t+1}^m = (1-δ) k_t^m + i_t^m, Human: h_{t+1} = h_t [1 + ρ n_{3t}].')
        print('   Based on Einarsson and Marquis (1997) for capital and human dynamics.\n')

        self.setup(**kwargs)

    #%% Set up model
    def setup(self, **kwargs):
        '''
        Sets parameters for simulation.

        Input:
            self : CapitalHumanModel class.
            kwargs : Override default parameters if provided.
        '''
        # Namespace for parameters
        setattr(self, 'par', SimpleNamespace())
        par = self.par

        print('\n--------------------------------------------------------------------------------')
        print('Parameters:')
        print('--------------------------------------------------------------------------------\n')

        # Market production and capital accumulation parameters
        par.A1 = 1.0  # Market efficiency
        par.alpha1 = 0.3  # Market capital's contribution
        par.delta = 0.1  # Depreciation rate
        par.s_m = 0.2  # Market investment rate
        par.theta = 1.0  # Fixed productivity (no shocks)
        par.N_H = 5.0  # Fixed effective labor (N_{1t} H_t)
        par.k_m_0 = 1.0  # Initial market capital

        # Human capital accumulation parameters
        par.rho = 0.0573  # Training effectiveness
        par.n3t = 0.2  # Fixed training time (fraction of total time)
        par.h_0 = 1.0  # Initial human capital

        # Shared parameters
        par.T = 100  # Number of time periods

        # Update parameters with kwargs if provided
        for key, val in kwargs.items():
            setattr(par, key, val)

        # Validate parameters
        assert par.A1 > 0.0
        assert 0.0 < par.alpha1 < 1.0
        assert 0.0 <= par.delta <= 1.0
        assert 0.0 < par.s_m < 1.0
        assert par.theta > 0.0
        assert par.N_H > 0.0
        assert par.k_m_0 > 0.0
        assert par.rho > 0.0
        assert 0.0 <= par.n3t <= 1.0
        assert par.h_0 > 0.0
        assert par.T > 0

        print(f'A1: {par.A1}, alpha1: {par.alpha1}')
        print(f'delta: {par.delta}, s_m: {par.s_m}')
        print(f'theta: {par.theta}, N_H: {par.N_H}')
        print(f'k_m_0: {par.k_m_0}')
        print(f'rho: {par.rho}, n3t: {par.n3t}')
        print(f'h_0: {par.h_0}')
        print(f'T: {par.T}')

    #%% Compute Market Production Function
    def compute_market_output(self, k_m, N_H, theta):
        '''
        Computes the market production function Y_t = θ_t A_1 (k_t^m)^α_1 (N_{1t} H_t)^(1-α_1).
        '''
        par = self.par
        Y = theta * par.A1 * (k_m ** par.alpha1) * (N_H ** (1 - par.alpha1))
        return Y

    #%% Simulate Capital and Human Accumulation
    def simulate_capital_human(self):
        '''
        Simulates market capital and human capital accumulation over time.

        Output:
            k_m_path : Array of market capital over time
            h_path : Array of human capital over time
        '''
        par = self.par
        k_m_path = np.zeros(par.T)
        h_path = np.zeros(par.T)
        k_m_path[0] = par.k_m_0
        h_path[0] = par.h_0

        for t in range(1, par.T):
            # Market capital
            Y_t = self.compute_market_output(k_m_path[t-1], par.N_H, par.theta)
            i_t_m = par.s_m * Y_t
            k_m_path[t] = (1 - par.delta) * k_m_path[t-1] + i_t_m

            # Human capital
            h_path[t] = h_path[t-1] * (1 + par.rho * par.n3t)

        return k_m_path, h_path

    #%% Plot Capital and Human Accumulation
    def plot_capital_human(self):
        '''
        Generates a line plot of market capital and human capital over time.
        '''
        par = self.par
        k_m_path, h_path = self.simulate_capital_human()
        time = np.arange(par.T)

        plt.figure(figsize=(10, 6))
        plt.plot(time, k_m_path, label='Market Capital ($k_t^m$)', color='blue')
        plt.plot(time, h_path, label='Human Capital ($h_t$)', color='green')
        plt.xlabel('Time ($t$)')
        plt.ylabel('Value')
        plt.title(f'Capital and Human Accumulation: $k_{{t+1}}^m = (1-\\delta) k_t^m + i_t^m$, ' +
                  f'$h_{{t+1}} = h_t [1 + \\rho n_{{3t}}]$, ' +
                  f'$\\delta = {par.delta}$, $s_m = {par.s_m}$, $\\rho = {par.rho}$, $n_{{3t}} = {par.n3t}$')
        plt.grid(True)
        plt.legend()
        plt.show()

#%% Run the Model
if __name__ == "__main__":
    # Initialize and run the model
    model = CapitalHumanModel()
    model.plot_capital_human()

"""# Technology Shock"""

# technology_shock_model.py
# -----------
# This code models and graphs the technology shock and its impact on market production from Einarsson and Marquis (1997).

#%% Imports from Python
import numpy as np
import matplotlib.pyplot as plt
from types import SimpleNamespace

#%% Technology Shock Model Class
class TechnologyShockModel():
    '''
    Methods:
        __init__(self, **kwargs) -> Initializes the technology shock model.
        setup(self, **kwargs) -> Sets parameters.
        compute_market_output(self, k_m, N_H, theta) -> Computes market production.
        simulate_shock(self) -> Simulates the technology shock, capital, and output.
        plot_shock(self) -> Generates and displays the shock and output plot.
    '''

    #%% Constructor
    def __init__(self, **kwargs):
        '''
        Initializes the technology shock model.

        Optional kwargs:
            All parameters can be overridden with kwargs.
        '''
        print('--------------------------------------------------------------------------------------------------')
        print('Technology Shock Model')
        print('--------------------------------------------------------------------------------------------------\n')
        print('   This model simulates and visualizes the technology shock θ_t and its impact on market production.')
        print('   Shock: log θ_{t+1} = (1-ρ_θ) log θ^* + ρ_θ log θ_t + ε_{t+1}, ε_{t+1} ~ N(0, σ_θ^2).')
        print('   Based on Einarsson and Marquis (1997) for technology dynamics.\n')

        self.setup(**kwargs)

    #%% Set up model
    def setup(self, **kwargs):
        '''
        Sets parameters for simulation.

        Input:
            self : TechnologyShockModel class.
            kwargs : Override default parameters if provided.
        '''
        # Namespace for parameters
        setattr(self, 'par', SimpleNamespace())
        par = self.par

        print('\n--------------------------------------------------------------------------------')
        print('Parameters:')
        print('--------------------------------------------------------------------------------\n')

        # Technology shock parameters
        par.theta_star = 1.0  # Steady-state technology level
        par.rho_theta = 0.95  # Persistence of shock
        par.sigma_theta = 0.02  # Standard deviation of innovations
        par.theta_0 = 1.0  # Initial technology level

        # Market production and capital accumulation parameters
        par.A1 = 1.0  # Market efficiency
        par.alpha1 = 0.3  # Market capital's contribution
        par.delta = 0.1  # Depreciation rate
        par.s_m = 0.2  # Market investment rate
        par.N_H = 5.0  # Fixed effective labor (N_{1t} h_t)
        par.k_m_0 = 1.0  # Initial market capital

        # Simulation parameters
        par.T = 100  # Number of time periods
        par.seed = 42  # Random seed for reproducibility

        # Update parameters with kwargs if provided
        for key, val in kwargs.items():
            setattr(par, key, val)

        # Validate parameters
        assert par.theta_star > 0.0
        assert 0.0 <= par.rho_theta < 1.0
        assert par.sigma_theta >= 0.0
        assert par.theta_0 > 0.0
        assert par.A1 > 0.0
        assert 0.0 < par.alpha1 < 1.0
        assert 0.0 <= par.delta <= 1.0
        assert 0.0 < par.s_m < 1.0
        assert par.N_H > 0.0
        assert par.k_m_0 > 0.0
        assert par.T > 0

        print(f'theta_star: {par.theta_star}, rho_theta: {par.rho_theta}, sigma_theta: {par.sigma_theta}')
        print(f'theta_0: {par.theta_0}')
        print(f'A1: {par.A1}, alpha1: {par.alpha1}')
        print(f'delta: {par.delta}, s_m: {par.s_m}')
        print(f'N_H: {par.N_H}, k_m_0: {par.k_m_0}')
        print(f'T: {par.T}, seed: {par.seed}')

        # Set random seed
        np.random.seed(par.seed)

    #%% Compute Market Production Function
    def compute_market_output(self, k_m, N_H, theta):
        '''
        Computes the market production function Y_t = θ_t A_1 (k_t^m)^α_1 (N_{1t} h_t)^(1-α_1).
        '''
        par = self.par
        Y = theta * par.A1 * (k_m ** par.alpha1) * (N_H ** (1 - par.alpha1))
        return Y

    #%% Simulate Technology Shock
    def simulate_shock(self):
        '''
        Simulates the technology shock, market capital, and output over time.

        Output:
            theta_path : Array of technology shock over time
            k_m_path : Array of market capital over time
            Y_path : Array of market output over time
        '''
        par = self.par
        log_theta_path = np.zeros(par.T)
        theta_path = np.zeros(par.T)
        k_m_path = np.zeros(par.T)
        Y_path = np.zeros(par.T)

        # Initial conditions
        log_theta_path[0] = np.log(par.theta_0)
        theta_path[0] = par.theta_0
        k_m_path[0] = par.k_m_0
        Y_path[0] = self.compute_market_output(k_m_path[0], par.N_H, theta_path[0])

        # Simulate AR(1) process for log θ_t
        for t in range(1, par.T):
            epsilon = np.random.normal(0, par.sigma_theta)
            log_theta_path[t] = (1 - par.rho_theta) * np.log(par.theta_star) + par.rho_theta * log_theta_path[t-1] + epsilon
            theta_path[t] = np.exp(log_theta_path[t])

            # Update market capital and output
            i_t_m = par.s_m * Y_path[t-1]
            k_m_path[t] = (1 - par.delta) * k_m_path[t-1] + i_t_m
            Y_path[t] = self.compute_market_output(k_m_path[t], par.N_H, theta_path[t])

        return theta_path, k_m_path, Y_path

    #%% Plot Technology Shock and Output
    def plot_shock(self):
        '''
        Generates a plot of the technology shock and market output over time with dual y-axes.
        '''
        par = self.par
        theta_path, k_m_path, Y_path = self.simulate_shock()
        time = np.arange(par.T)

        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plot technology shock on the left y-axis
        color = 'tab:blue'
        ax1.set_xlabel('Time ($t$)')
        ax1.set_ylabel('Technology Shock ($\\theta_t$)', color=color)
        ax1.plot(time, theta_path, label='Technology Shock ($\\theta_t$)', color=color)
        ax1.tick_params(axis='y', labelcolor=color)
        ax1.grid(True)

        # Create a second y-axis for market output
        ax2 = ax1.twinx()
        color = 'tab:orange'
        ax2.set_ylabel('Market Output ($Y_t$)', color=color)
        ax2.plot(time, Y_path, label='Market Output ($Y_t$)', color=color)
        ax2.tick_params(axis='y', labelcolor=color)

        # Title and legend
        fig.suptitle(f'Technology Shock and Market Output: $\\log \\theta_{{t+1}} = (1-\\rho_\\theta) \\log \\theta^* + \\rho_\\theta \\log \\theta_t + \\epsilon_{{t+1}}$, ' +
                     f'$\\rho_\\theta = {par.rho_theta}$, $\\sigma_\\theta = {par.sigma_theta}$')
        fig.tight_layout(rect=[0, 0, 1, 0.95])
        fig.legend(loc='upper center', bbox_to_anchor=(0.5, -0.05), ncol=2)
        plt.show()

#%% Run the Model
if __name__ == "__main__":
    # Initialize and run the model
    model = TechnologyShockModel()
    model.plot_shock()

"""### Market production (Yt) is directly influenced by technology shocks (θt), as modeled by the equation: Yt = θt * A1 * (k_t^m)^α1 * (N_1t * ht)^(1 - α1). This makes Yt a crucial variable for understanding the economic impact of these shocks. A dual-axis plot effectively visualizes how changes in θt affect Yt, showcasing the shock's role in driving economic booms and busts. Furthermore, the plot helps demonstrate how the shock propagates to other key variables like work effort (n_1t) and home production (n_2t). This visualization supports the model's ability to generate comovement dynamics observed in real-world data using a single shock. Including Yt in the graph enhances its interpretability and underscores the economic significance of the technology shock."""